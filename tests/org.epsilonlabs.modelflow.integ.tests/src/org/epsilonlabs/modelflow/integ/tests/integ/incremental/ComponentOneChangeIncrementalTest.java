/*******************************************************************************
 * Copyright (c) 2020 The University of York.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 ******************************************************************************/
package org.epsilonlabs.modelflow.integ.tests.integ.incremental;

import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import org.epsilonlabs.modelflow.dom.IWorkflow;
import org.epsilonlabs.modelflow.execution.graph.node.TaskState;
import org.epsilonlabs.modelflow.integ.tests.common.workflow.ExampleWorkflows;
import org.epsilonlabs.modelflow.management.param.hash.Hasher;
import org.epsilonlabs.modelflow.mmc.core.plugin.CorePlugin;
import org.epsilonlabs.modelflow.mmc.emf.plugin.EMFPlugin;
import org.epsilonlabs.modelflow.mmc.epsilon.plugin.EpsilonPlugin;
import org.epsilonlabs.modelflow.mmc.gmf.plugin.GMFPlugin;
import org.epsilonlabs.modelflow.registry.ResourceFactoryRegistry;
import org.epsilonlabs.modelflow.registry.TaskFactoryRegistry;
import org.epsilonlabs.modelflow.tests.common.IncrementalTest;
import org.epsilonlabs.modelflow.tests.common.validator.AllTaskStateValidator;
import org.epsilonlabs.modelflow.tests.common.validator.CompositeValidator;
import org.epsilonlabs.modelflow.tests.common.validator.IValidate;
import org.epsilonlabs.modelflow.tests.common.validator.TaskStateValidator;
import org.junit.BeforeClass;
import org.junit.Test;

import com.google.inject.Guice;
import com.google.inject.Injector;

public class ComponentOneChangeIncrementalTest extends IncrementalTest {
	
	@BeforeClass
	public static void configureModule() {
		Injector injector = Guice.createInjector(new EpsilonPlugin(), new EMFPlugin(), new CorePlugin(), new GMFPlugin());
		taskFactoryRegistry = injector.getInstance(TaskFactoryRegistry.class);
		resFactoryRegistry = injector.getInstance(ResourceFactoryRegistry.class);
	}
	
	/** Validation/Modification Helpers */

	protected void addComment(String file) {
		String fileName = DIR + file;
		File file2 = new File(fileName);
		assertTrue("File not found", file2.exists());
		String hash1 = Hasher.computeHashForFile(file2);
		try (FileWriter fw = new FileWriter(fileName, true)) {
			BufferedWriter out = new BufferedWriter(fw);
			out.newLine();
			out.write("//explicit modification");
			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			fail(e.getMessage());
		}
		String hash2 = Hasher.computeHashForFile(new File(fileName));
		assertNotEquals("hashes are the same", hash1, hash2);
	}
	
	protected void protectedRegionChange(Boolean inside, String fileRelativePath) {
		String filePath = DIR + fileRelativePath;
		File file = new File(filePath);
		assertTrue("File not found", file.exists());
		String hash1 = Hasher.computeHashForFile(file);
	
		BufferedReader reader;
		StringBuffer inputBuffer = new StringBuffer();
		try {
			reader = new BufferedReader(new FileReader(file));
			String line;
			while ((line = reader.readLine()) != null) {
				if (inside && line.trim() != null && line.trim().equals("// TODO: Autogenerated method stub")) {
					line = line.replace("// TODO: Autogenerated method stub", "System.out.println(\"inside\");");
				} else if (!inside && line.trim() != null && line.trim().equals("private String name;")) {
					line = line.replace("name", "newName");
				}
				inputBuffer.append(line + "\n");
			}
			reader.close();
			String modifiedString = inputBuffer.toString();
			FileOutputStream fileOut = new FileOutputStream(file);
	        fileOut.write(modifiedString.getBytes());
	        fileOut.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		String hash2 = Hasher.computeHashForFile(new File(filePath));
		assertNotEquals("hashes are the same", hash1, hash2);
	}
	
	protected void modifySourceModel(String fileRelativePath) {
		String filePath = DIR + fileRelativePath;
		File file = new File(filePath);
		assertTrue("File not found", file.exists());
		String hash1 = Hasher.computeHashForFile(file);
	
		BufferedReader reader;
		StringBuffer inputBuffer = new StringBuffer();
		try {
			reader = new BufferedReader(new FileReader(file));
			String line;
			while ((line = reader.readLine()) != null) {
				if (fileRelativePath.endsWith("config.model")) {
					if (line.contains("value")) {
						line = line.replace("0.5", "1.0");
					}
					inputBuffer.append(line + "\n");					
				}
				else if (fileRelativePath.endsWith("component.model")) {
					if (line.contains("difference")) {
						line = line.replace("difference", "diff");
					}
					inputBuffer.append(line + "\n");					
				}
				else if (fileRelativePath.endsWith("extended.model")) {
					if (line.contains("difference")) {
						line = line.replace("difference", "diff");
					}
					inputBuffer.append(line + "\n");					
				}
			}
			reader.close();
			String modifiedString = inputBuffer.toString();
			FileOutputStream fileOut = new FileOutputStream(file);
	        fileOut.write(modifiedString.getBytes());
	        fileOut.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		String hash2 = Hasher.computeHashForFile(new File(filePath));
		assertNotEquals("hashes are the same", hash1, hash2);
	}
	
	/** TESTING PROCESS */

	@Override
	protected void setupSource() {
		IWorkflow w = ExampleWorkflows.getComponentWorkflow();
		w.getTasks().stream()
		.filter(t -> "m2t".equals(t.getName()))
		.forEach(t -> t.getProperties().stream()
				.filter(p -> "outputRoot".equals(p.getKey()))
				.forEach(p -> 
				p.setValue(DIR + "src-gen/")));
		module.setWorkflow(w);
	}

	/** TESTS */

	@Test
	public void testNoChanges() {
		second = AllTaskStateValidator.SKIPPED;
		modifications = new Runnable() {
			@Override public void run() {}
		};
	}

	/** 
	 * TASK SOURCE CHANGES THAT DONT AFFECT OUTPUT
	 */
	
	@Test
	public void testChangesToValidationTaskSource() {
		modifications = new Runnable() {
			@Override
			public void run() {
				addComment("mmt/validate.evl");
			}
		};
		second = expect(true, false, false);
	}
	
	@Test
	public void testChangesToTransformationTaskSource() {
		modifications = new Runnable() {
			@Override
			public void run() {
				addComment("mmt/addTolerances.etl");
			}
		};
		second = expect(false, true, false);
	}
	
	@Test
	public void testChangesToGenerationTaskSource() {
		modifications = new Runnable() {
			@Override
			public void run() {
				addComment("mmt/generateReactive.egx");
			}
		};
		second = expect(false, false, true);
	}
	
	@Test
	public void testChangesToGenerationTemplateTaskSource() {
		modifications = new Runnable() {
			@Override
			public void run() {
				addComment("mmt/template/reactive/component.egl");
			}
		};
		second = expect(false, false, true);
	}

	/** 
	 * GENERATED FILES OUTPUT CHANGES
	 */

	@Test
	public void testChangesToGeneratedFilesInProtected() {
		modifications = new Runnable() {
			@Override
			public void run() {
				protectedRegionChange(true,"src-gen/reactive/BoilerControllerReactive.java"); 
			}
		};
		second = expect(false, false, false);
	}
	
	@Test
	public void testChangesToGeneratedFilesOutsideProtected() {
		protect = false;
		modifications = new Runnable() {
			@Override
			public void run() {
				protectedRegionChange(false, "src-gen/reactive/BoilerControllerReactive.java"); 
			}
		};
		second = expect(false, false, true);
	}
	
	@Test
	public void testChangesToGeneratedFilesOutsideProtectedNoAction() {
		modifications = new Runnable() {
			@Override
			public void run() {
				protectedRegionChange(false, "src-gen/reactive/BoilerControllerReactive.java"); 
			}
		};
		second = expect(false, false, false);
	}
	
	/** 
	 * MODEL CHANGES
	 */
	
	@Test
	public void testTwoExecutionsChangesToConfigurationModel() {
		modifications = new Runnable() {
			@Override
			public void run() {
				modifySourceModel("m/config.model");
			}
		};
		second = expect(true, true, true);
	}
	
	@Test
	public void testTwoExecutionsChangesToComponentModel() {
		modifications = new Runnable() {
			@Override
			public void run() {
				modifySourceModel("m/component.model");
			}
		};
		second = expect(true, true, true);
	}
	
	@Test
	public void testTwoExecutionsChangesToMergedModelExecuteTransform() {
		protect = false;
		modifications = new Runnable() {
			@Override
			public void run() {
				modifySourceModel("m/extended.model");
			}
		};
		second = expect(false, true, false);
	}
	
	@Test
	public void testTwoExecutionsChangesToMergedModelSkipTransform() {
		modifications = new Runnable() {
			@Override
			public void run() {
				modifySourceModel("m/extended.model");
			}
		};
		second = expect(false, false, true);
	}
	
	/** 
	 * UTIL
	 */
	
	private static IValidate expect(boolean validateTaskExecuted, boolean transformTaskExecuted, boolean generateTaskExecuted) {
		TaskStateValidator x = new TaskStateValidator((validateTaskExecuted ? TaskState.EXECUTED : TaskState.SKIPPED), "validate");
		TaskStateValidator y = new TaskStateValidator((transformTaskExecuted ? TaskState.EXECUTED : TaskState.SKIPPED), "m2m");
		TaskStateValidator z = new TaskStateValidator((generateTaskExecuted ? TaskState.EXECUTED : TaskState.SKIPPED), "m2t");
		return new CompositeValidator(y, x, z);
	}

}
